# 파이썬 환경 세팅
## 개발 플랫폼 설치
> 아나콘다는 파이썬과 여러 패키지(pandas, scipy, jupyter, numpy) 를 모아놓은 개발 플랫폼이다.

아나콘다와 딥러닝 프레임워크인 tensorflow, keras 를 설치한다.

* www.anaconda.com 접속해 아나콘다 최신 다운로드 및 설치
    * 아나콘다 설치전, 충돌 방지를 위해 기존 파이썬을 지워두자.
* 쉘에서 pip 를 이용해 tensorflow, keras 를 설치  
    ```
    // tensorflow 2.0.1 이 정상 작동하지 않아, 2.0.0 설치
    pip install tensorflow==2.0.0
    pip install keras
    ```

## 선택. VSCode 설정
IDE 로 VSCode 사용시, 아래 extension 3개를 설치하고 적용하자.
![](https://images.velog.io/images/megachj/post/6127ed01-aaf0-4b95-a9a8-10c4e784ffd5/1.PNG)

# 퍼셉트론
## 퍼센트론이란
> 퍼셉트론 정확히는 인공 뉴런, 단순 퍼셉트론은 다수의 신호를 입력으로 받아 하나의 신호를 출력한다. 
> 그리고 신호는 흐른다(1)/안 흐른다(0) 의 두 가지 값만 가진다.

![](https://images.velog.io/images/megachj/post/1f4badf5-ec83-4ef3-9343-55e9ebbddb7b/2.png)
위 그림은 정의를 바탕으로 2개의 신호를 입력으로 받은 퍼셉트론의 예(그래프 표현)이다. 여기서 x1, x2는 입력 신호이고, y 는 출력 신호, w1, w2는 가중치를 뜻한다.

그림의 원은 `뉴런` 혹은 `노드`라고 부르고, 퍼셉트론의 동작 원리는 다음과 같다.
```
* 신호 전달: 뉴런에서는 자신의 값에 각각 고유의 `가중치를 곱해` 전달한다.
* 출력: 뉴런에서는 보내온 신호의 총합이 `임계값`을 넘을때만 1을 출력한다.
```

따라서 신호 전달을 수식으로 나타내면 아래 수식이 된다.
![](https://images.velog.io/images/megachj/post/5cafdb10-07d1-4ba0-9264-2a0c352d838f/3.png)

여기서 부등식 우변(세타)를 좌변으로 이항시켜 `-세타를 b로 치환`할 수 있다.
이때 b를 `편향(bias)`라고 한다.

### 질문: 퍼셉트론 수식이 왜 1차 부등식이 되는가?
처음 퍼셉트론 정의에서는 단순히 `다수의 입력`에 대해 `하나의 출력`을 하는 것으로 정의했다. 그런데 이를 수식으로 전개할 때, 왜 꼭 x1, x2 로만 전개하는가? 
즉 정의대로만 하면 x1, x1^2, sin(x1)등의  g(x1) 으로 입력도 가능하지 않는가?

이는 입력값이 함수값인 f(g(x)) 라는 합성함수를 의미한다.
g(x) = x^2 이라고 가정해보자. 정의역 x가 실수 전체집합일 때, g(x) 치역은 x>=0 인 실수이고, f 입장에선 정의역이 실수 전체 집합에서 x>=0 인 실수로 축소된 것 뿐이다.

즉 f함수 입장에서는 그냥 x로 4가 들어오던, g(x)=x^2 이어서 x가 2일때 4가 되어서 들어오건 아무런 의미가 없다. 오히려 정의역 범위가 축소되므로 기존 f(x) 함수값의 치역이 같거나 더 크다. 즉 합성함수의 치역이 기존함수의 치역에 부분집합이 된다. (g함수가 실수->복소수로 대응되는 함수는 제외)

![](https://images.velog.io/images/megachj/post/6876bc6a-cdf7-415d-8714-6476d110483b/4.PNG)

프로그래밍의 함수로 예를 들어보자.
```
// 함수 f = w1x1 + w2x2
function f(int x1, int x2) {
    return w1*x1 + w2*x2;
}

// 함수 g = x^2
function g(int x) {
    return x*x;
}

// 함수 f 입장에선, 4, 9 로 인자가 들어오건
// g(2) = 4, g(3) = 9, 즉 g함수를 거쳐 인자가 들어오건 차이가 없다.
f(4, 9);
f(g(2), g(3));
```

## 단순 논리 회로
AND 게이트와 같은 단순 논리 회로를 위에서 살펴본 퍼셉트론으로 표현할 수 있을까?

이 말은 논리 연산 AND 와 출력이 같게 나오게 하는 w1, w2, 세타가 존재하냐는 것이고, 결론을 말하면 그러한 조합은 무수히 많다.
예를 들어 (0.5, 0.5, 0.8)로 잡고 계산하면, AND 와 동일하게 출력된다.

AND, NAND, OR 게이트는 이러한 조합이 존재하고, 따라서 이 3개의 게이트는 퍼셉트론으로 표현할 수 있다.

## 퍼셉트론 구현하기
퍼셉트론으로 표현한 AND, NAND, OR 게이트를 파이썬으로 구현해보자.
```python
def AND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.7
    tmp = np.sum(w*x) + b # 퍼셉트론 표현 w1x1 + w2x2
    if tmp <= 0:
        return 0
    else:
        return 1

def NAND(x1, x2):
    x = np.array([x1, x2])
    w = np.array([-0.5, -0.5]) # AND의 가중치에 부호 반대
    b = 0.7 # AND의 편향에 부호 반대
    tmp = np.sum(w*x) + b # 퍼셉트론 표현 w1x1 + w2x2
    if tmp <= 0:
        return 0
    else:
        return 1
        
def OR(x1, x2):
    x = np.array([x1, x2])
    w = np.array([0.5, 0.5])
    b = -0.2 # AND의 편향과 값이 다름
    tmp = np.sum(w*x) + b # 퍼셉트론 표현 w1x1 + w2x2
    if tmp <= 0:
        return 0
    else:
        return 1
```

## 퍼셉트론의 한계
XOR 게이트는 위에서 살펴본 단층 퍼셉트론으로는 표현할 수 없다.
왜냐하면 퍼셉트론은 위의 수식대로 1차 부등식(직선)의 영역에 따라 출력 값이 결정되는데 아래와 같은 XOR 진리 값을 직선 하나로 영역을 분리할 수 없다.

![](https://images.velog.io/images/megachj/post/126c11a3-95a1-4a38-bad2-1baefbed7a5a/5.png)
* 하지만 선형이 아닌 비선형이라면 XOR 게이트를 구현할 수 있다.

## 다층 퍼셉트론
퍼셉트론을 여러개 조합해서 사용하면 XOR 을 구현할 수 있다.

기존 AND, NAND, OR 을 조합해서도 만들 수 있다.
```python
def XOR(x1, x2):
    s1 = NAND(x1, x2)
    s2 = OR(x1, x2)
    y = AND(s1, s2)
    return y
```

그래프로 표현하면 이렇게 뉴런(노드)가 구성되는 것이다.
![](https://images.velog.io/images/megachj/post/e5f83f15-f673-48f9-a7af-cb19c1eee476/6.jpeg)

## NAND에서 컴퓨터까지
다층 퍼셉트론은 이런 기본 게이트 말고도 복잡한 회로들을 만들 수 있다.
예를 들면, 가산기, 2진수 10진수 인코더, 패리티 검사 회로 등 모든 것을 퍼셉트론으로 표현할 수 있다. 최종적으로는 퍼셉트론으로 `컴퓨터`도 표현할 수 있다.

컴퓨터 내부의 모든 회로들이 NAND 게이트의 조합만으로 구현될 수 있는데,
위에서 살펴본 것처럼 NAND 게이트를 퍼셉트론으로 표현할 수 있으므로 퍼셉트론으로 컴퓨터를 만들 수 있다.

이론상 2층 퍼셉트론이면 컴퓨터를 만들 수 있다고 하는데, 정확히는 2층 퍼셉트론, 비선형인 시그모이드 함수를 활성화 함수로 이용하면 임의의 함수를 표현할 수 있다는 사실이 증명되었다고 한다.

그렇지만 2층 퍼셉트론 구조에서 가중치를 적절히 설정해 컴퓨터를 만들기란 너무 어렵고, 일반적인 회로처럼 NAND 등의 저수준 소자에서 시작해 컴퓨터 부품(모듈)을 단계적으로 만들어가는 쪽이 자연스러운 방법이다.
* 기본 게이트(NAND, AND 등) -> 가산기 -> ALU -> CPU 

**결론은 퍼셉트론은 층을 거듭 쌓으면 `비선형적인 표현`도 가능하고, `이론상 컴퓨터가 수행하는 처리`도 모두 표현할 수 있다.**